{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport * as Device from \"expo-device\";\nimport * as Notifications from \"expo-notifications\";\nimport updateDataUser from \"../updateDataUser\";\nexport var validatePushToken = function () {\n  var _ref = _asyncToGenerator(function* (user, setUser, jwt) {\n    var _push_token = yield registerForPushNotificationsAsync();\n\n    if (user != null && user.id && _push_token && (user == null ? void 0 : user.pushToken) !== _push_token) {\n      setUser(_objectSpread(_objectSpread({}, user), {}, {\n        pushToken: _push_token\n      }));\n      var dataSend = {\n        pushToken: _push_token,\n        id: user.id\n      };\n      updateDataUser.userPushToken(dataSend, jwt);\n    }\n  });\n\n  return function validatePushToken(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var SettingNotifications = function SettingNotifications() {\n  Notifications.setNotificationHandler({\n    handleNotification: function () {\n      var _handleNotification = _asyncToGenerator(function* () {\n        return {\n          shouldShowAlert: true,\n          shouldPlaySound: true,\n          shouldSetBadge: true\n        };\n      });\n\n      function handleNotification() {\n        return _handleNotification.apply(this, arguments);\n      }\n\n      return handleNotification;\n    }()\n  });\n};\nexport function registerForPushNotificationsAsync() {\n  return _registerForPushNotificationsAsync.apply(this, arguments);\n}\n\nfunction _registerForPushNotificationsAsync() {\n  _registerForPushNotificationsAsync = _asyncToGenerator(function* () {\n    var token;\n\n    if (Device.isDevice) {\n      var _yield$Notifications$ = yield Notifications.getPermissionsAsync(),\n          existingStatus = _yield$Notifications$.status;\n\n      var finalStatus = existingStatus;\n\n      if (existingStatus !== \"granted\") {\n        var _yield$Notifications$2 = yield Notifications.requestPermissionsAsync(),\n            status = _yield$Notifications$2.status;\n\n        finalStatus = status;\n      }\n\n      if (finalStatus !== \"granted\") {\n        return;\n      }\n\n      token = (yield Notifications.getExpoPushTokenAsync()).data;\n    } else {}\n\n    if (Platform.OS === \"android\") {\n      Notifications.setNotificationChannelAsync(\"default\", {\n        name: \"default\",\n        importance: Notifications.AndroidImportance.MAX,\n        vibrationPattern: [0, 250, 250, 250],\n        lightColor: \"#FF231F7C\"\n      });\n    }\n\n    return token;\n  });\n  return _registerForPushNotificationsAsync.apply(this, arguments);\n}","map":{"version":3,"names":["Device","Notifications","updateDataUser","validatePushToken","user","setUser","jwt","_push_token","registerForPushNotificationsAsync","id","pushToken","dataSend","userPushToken","SettingNotifications","setNotificationHandler","handleNotification","shouldShowAlert","shouldPlaySound","shouldSetBadge","token","isDevice","getPermissionsAsync","existingStatus","status","finalStatus","requestPermissionsAsync","getExpoPushTokenAsync","data","Platform","OS","setNotificationChannelAsync","name","importance","AndroidImportance","MAX","vibrationPattern","lightColor"],"sources":["/Users/andresfelipepinillameneses/Documents/John 2/front/src/helpers/validatePushToken/index.js"],"sourcesContent":["import * as Device from \"expo-device\";\nimport * as Notifications from \"expo-notifications\";\n\nimport updateDataUser from \"../updateDataUser\";\n\nexport const validatePushToken = async (user, setUser, jwt) => {\n  const _push_token = await registerForPushNotificationsAsync();\n\n  if (user?.id && _push_token && user?.pushToken !== _push_token) {\n    setUser({ ...user, pushToken: _push_token });\n    const dataSend = {\n      pushToken: _push_token,\n      id: user.id,\n    };\n    updateDataUser.userPushToken(dataSend, jwt);\n  }\n};\n\nexport const SettingNotifications = () => {\n  Notifications.setNotificationHandler({\n    handleNotification: async () => ({\n      shouldShowAlert: true,\n      shouldPlaySound: true,\n      shouldSetBadge: true,\n    }),\n  });\n};\n\nexport async function registerForPushNotificationsAsync() {\n  let token;\n  if (Device.isDevice) {\n    const { status: existingStatus } =\n      await Notifications.getPermissionsAsync();\n    let finalStatus = existingStatus;\n    if (existingStatus !== \"granted\") {\n      const { status } = await Notifications.requestPermissionsAsync();\n      finalStatus = status;\n    }\n    if (finalStatus !== \"granted\") {\n      //   console.log(\"Failed to get push token for push notification!\");\n      return;\n    }\n    token = (await Notifications.getExpoPushTokenAsync()).data;\n    // console.log(token);\n  } else {\n    // alert(\"Must use physical device for Push Notifications\");\n  }\n\n  if (Platform.OS === \"android\") {\n    Notifications.setNotificationChannelAsync(\"default\", {\n      name: \"default\",\n      importance: Notifications.AndroidImportance.MAX,\n      vibrationPattern: [0, 250, 250, 250],\n      lightColor: \"#FF231F7C\",\n    });\n  }\n\n  return token;\n}\n"],"mappings":";;;;;;;AAAA,OAAO,KAAKA,MAAZ,MAAwB,aAAxB;AACA,OAAO,KAAKC,aAAZ,MAA+B,oBAA/B;AAEA,OAAOC,cAAP;AAEA,OAAO,IAAMC,iBAAiB;EAAA,6BAAG,WAAOC,IAAP,EAAaC,OAAb,EAAsBC,GAAtB,EAA8B;IAC7D,IAAMC,WAAW,SAASC,iCAAiC,EAA3D;;IAEA,IAAIJ,IAAI,QAAJ,IAAAA,IAAI,CAAEK,EAAN,IAAYF,WAAZ,IAA2B,CAAAH,IAAI,QAAJ,YAAAA,IAAI,CAAEM,SAAN,MAAoBH,WAAnD,EAAgE;MAC9DF,OAAO,iCAAMD,IAAN;QAAYM,SAAS,EAAEH;MAAvB,GAAP;MACA,IAAMI,QAAQ,GAAG;QACfD,SAAS,EAAEH,WADI;QAEfE,EAAE,EAAEL,IAAI,CAACK;MAFM,CAAjB;MAIAP,cAAc,CAACU,aAAf,CAA6BD,QAA7B,EAAuCL,GAAvC;IACD;EACF,CAX6B;;EAAA,gBAAjBH,iBAAiB;IAAA;EAAA;AAAA,GAAvB;AAaP,OAAO,IAAMU,oBAAoB,GAAG,SAAvBA,oBAAuB,GAAM;EACxCZ,aAAa,CAACa,sBAAd,CAAqC;IACnCC,kBAAkB;MAAA,4CAAE;QAAA,OAAa;UAC/BC,eAAe,EAAE,IADc;UAE/BC,eAAe,EAAE,IAFc;UAG/BC,cAAc,EAAE;QAHe,CAAb;MAAA,CAAF;;MAAA;QAAA;MAAA;;MAAA;IAAA;EADiB,CAArC;AAOD,CARM;AAUP,gBAAsBV,iCAAtB;EAAA;AAAA;;;yDAAO,aAAmD;IACxD,IAAIW,KAAJ;;IACA,IAAInB,MAAM,CAACoB,QAAX,EAAqB;MACnB,kCACQnB,aAAa,CAACoB,mBAAd,EADR;MAAA,IAAgBC,cAAhB,yBAAQC,MAAR;;MAEA,IAAIC,WAAW,GAAGF,cAAlB;;MACA,IAAIA,cAAc,KAAK,SAAvB,EAAkC;QAChC,mCAAyBrB,aAAa,CAACwB,uBAAd,EAAzB;QAAA,IAAQF,MAAR,0BAAQA,MAAR;;QACAC,WAAW,GAAGD,MAAd;MACD;;MACD,IAAIC,WAAW,KAAK,SAApB,EAA+B;QAE7B;MACD;;MACDL,KAAK,GAAG,OAAOlB,aAAa,CAACyB,qBAAd,EAAP,EAA8CC,IAAtD;IAED,CAdD,MAcO,CAEN;;IAED,IAAIC,QAAQ,CAACC,EAAT,KAAgB,SAApB,EAA+B;MAC7B5B,aAAa,CAAC6B,2BAAd,CAA0C,SAA1C,EAAqD;QACnDC,IAAI,EAAE,SAD6C;QAEnDC,UAAU,EAAE/B,aAAa,CAACgC,iBAAd,CAAgCC,GAFO;QAGnDC,gBAAgB,EAAE,CAAC,CAAD,EAAI,GAAJ,EAAS,GAAT,EAAc,GAAd,CAHiC;QAInDC,UAAU,EAAE;MAJuC,CAArD;IAMD;;IAED,OAAOjB,KAAP;EACD,C"},"metadata":{},"sourceType":"module"}